## 一、EurekaClient注册的秘密

当我们在Client配置文件中配置`defaultZone`时，Client会自动的向配置的服务器连接，并且在断线时连接其他可用的Server，比如如下配置：

```properties
eureka.client.service-url.defaultZone=
http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eureka
```

如上图所示，Eureka Client配置对应的Eureka Server地址分别是8761、8762、8763、8764。这里存在两个问题：

- Eureka Client会将自身信息分别注册到这四个地址吗？
- Eureka Clinent注册机制是怎样的？

源码面前一目了然，带着这两个问题我们通过源码来解答这两个问题。主要的类为：`RetryableEurekaHttpClient`

### 1.execut()

Eureka Client在启动的时候注册源码如下：
`RetryableEurekaHttpClient`中的`execut`方法:

```java
@Override
protected <R> EurekaHttpResponse<R> execute(RequestExecutor<R> requestExecutor) {
    List<EurekaEndpoint> candidateHosts = null;
    int endpointIdx = 0;
    for (int retry = 0; retry < numberOfRetries; retry++) {
        EurekaHttpClient currentHttpClient = delegate.get();
        EurekaEndpoint currentEndpoint = null;
        if (currentHttpClient == null) {
            if (candidateHosts == null) {
                candidateHosts = getHostCandidates();
                if (candidateHosts.isEmpty()) {
                    throw new TransportException("There is no known eureka server; cluster server list is empty");
                }
            }
            if (endpointIdx >= candidateHosts.size()) {
                throw new TransportException("Cannot execute request on any known server");
            }

            currentEndpoint = candidateHosts.get(endpointIdx++);
            currentHttpClient = clientFactory.newClient(currentEndpoint);
        }

        try {
            EurekaHttpResponse<R> response = requestExecutor.execute(currentHttpClient);
            if (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) {
                delegate.set(currentHttpClient);
                if (retry > 0) {
                    logger.info("Request execution succeeded on retry #{}", retry);
                }
                return response;
            }
            logger.warn("Request execution failure with status code {}; retrying on another server if available", response.getStatusCode());
        } catch (Exception e) {
            logger.warn("Request execution failed with message: {}", e.getMessage());  // just log message as the underlying client should log the stacktrace
        }

        // Connection error or 5xx from the server that must be retried on another server
        delegate.compareAndSet(currentHttpClient, null);
        if (currentEndpoint != null) {
            quarantineSet.add(currentEndpoint);
        }
    }
    throw new TransportException("Retry limit reached; giving up on completing the request");
}
```

因为代码长度过长，这里我们缩减一下：

```java
int endpointIdx = 0;
//用来保存所有Eureka Server信息(8761、8762、8763、8764)
List<EurekaEndpoint> candidateHosts = null;
//numberOfRetries的值代码写死默认为3次
for (int retry = 0; retry < numberOfRetries; retry++) {
	/**
	 *首次进入循环时，获取全量的Eureka Server信息(8761、8762、8763、8764)
	 */
	if (candidateHosts == null) {
        candidateHosts = getHostCandidates();
    }
	/**
	 *通过endpointIdx自增，依次获取Eureka Server信息，然后发送
	 *注册的Post请求.
	 */
    currentEndpoint = candidateHosts.get(endpointIdx++);
    currentHttpClient = clientFactory.newClient(currentEndpoint);
    try {
       /**
	 	*发送注册的Post请求动作，注意如果成功，则跳出循环，如果失败则
	 	*根据endpointIdx依次获取下一个Eureka Server.
	 	*/
        response = requestExecutor.execute(currentHttpClient);
        return respones;
    } catch (Exception e) {
        //向注册中心(Eureka Server)发起注册的post出现异常时，打印日志...
    }
    //如果此次注册动作失败，将当前的信息保存到quarantineSet中(一个Set集合)
    if (currentEndpoint != null) {
        quarantineSet.add(currentEndpoint);
    }
}
//如果都失败,则以异常形式抛出...
throw new TransportException("Retry limit reached; giving up on completing the request");

```

在第10行，还有一个重要方法getHostCandidates()，我们也把源码贴出，一并查看

### 2.getHostCandidates()

```java
private List<EurekaEndpoint> getHostCandidates() {
    List<EurekaEndpoint> candidateHosts = clusterResolver.getClusterEndpoints();
    quarantineSet.retainAll(candidateHosts);

    // If enough hosts are bad, we have no choice but start over again
    int threshold = (int) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage());
    if (quarantineSet.isEmpty()) {
        // no-op
    } else if (quarantineSet.size() >= threshold) {
        logger.debug("Clearing quarantined list of size {}", quarantineSet.size());
        quarantineSet.clear();
    } else {
        List<EurekaEndpoint> remainingHosts = new ArrayList<>(candidateHosts.size());
        for (EurekaEndpoint endpoint : candidateHosts) {
            if (!quarantineSet.contains(endpoint)) {
                remainingHosts.add(endpoint);
            }
        }
        candidateHosts = remainingHosts;
    }

    return candidateHosts;
}
```

这里我们也精简一下：

```java
private List<EurekaEndpoint> getHostCandidates() {
    /**
     * 获取所有defaultZone配置的注册中心信息(Eureka Server)，
     * 在本文例子中代表4个(8761、8762、8763、8764)Eureka Server
     */
    List candidateHosts = clusterResolver.getClusterEndpoints();
    /**
     * quarantineSet这个Set集合中保存的是不可用的Eureka Server
     * 此处是拿不可用的Eureka Server与全量的Eureka Server取交集
     */
    quarantineSet.retainAll(candidateHosts);
    /**
     * 根据RetryableClientQuarantineRefreshPercentage参数计算阈值
     * 该阈值后续会和quarantineSet中保存的不可用的Eureka Server个数
     * 作比较，从而判断是否返回全量的Eureka Server还是过滤掉不可用的
     * Eureka Server。
     */
    int threshold = 
       (int) (
        candidateHosts.size()
              *
        transportConfig.getRetryableClientQuarantineRefreshPercentage()
        );
    if (quarantineSet.isEmpty()) {
        /**
         * 首次进入的时候，此时quarantineSet为空，直接返回全量的
         * Eureka Server列表
         */
    } else if (quarantineSet.size() >= threshold) {
        /**
         * 将不可用的Eureka Server与threshold值相比较，如果不可
         * 用的Eureka Server个数大于阈值，则将之间保存的Eureka
         * Server内容直接清空，并返回全量的Eureka Server列表。
         */
        quarantineSet.clear();
    } else {
        /**
         * 通过quarantineSet集合保存不可用的Eureka Server来过滤
         * 全量的EurekaServer，从而获取此次Eureka Client要注册要
         * 注册的Eureka Server实例地址。
         */
        List<EurekaEndpoint> remainingHosts = new ArrayList<>(candidateHosts.size());
        for (EurekaEndpoint endpoint : candidateHosts) {
            if (!quarantineSet.contains(endpoint)) {
                remainingHosts.add(endpoint);
            }
        }
        candidateHosts = remainingHosts;
    }
    return candidateHosts;
}
```

### 3.总结两个方法

#### getHostCandidates

1. 先从配置文件中获取所有Zone配置
2. 将这些信息保存到一个`quarantineSet`集合中，为不可用Eureka Server的集合
3. 计算阈值`threshold`（这个值很有用，后面会说到）
4. 判断是否第一次进入，如果是直接返回全部信息
5. 判断不可用集合是否大于阈值，如果是清空Set，即返回空
6. 最后的else进行添加，将可用的Server保存到List返回

#### execut

1. 首先循环3次，这个次数是固定的，`DEFAULT_NUMBER_OF_RETRIES = 3;`
2. 调用`getHostCandidates()`方法获取可用的`Eureka Server List`
3. 获取完毕循环请求再此集合中的Server
4. 如果成功，跳出返回
5. 如果失败，`endpointIdx++`，并将此Server保存到`quarantineSet`中，即不可用Eureka Server
6. 如果全部都失败，抛出异常

### 4.轮询请求

因为默认只请求3次，那么比如我们的例子，有4个Server，前面三个都挂了，便不会再尝试8764了，直到下一次轮询请求连接Server。

这时因为不可用Set中已经保存了8761,8762,8763，所以，在我们的想法中，这一次请求会直接尝试8764，然后成功连接，然而这时错的，==它并不会走到这个分支，而是被上面的`else if (quarantineSet.size() >= threshold)`这个分支所拦截==，因为Set的容量为3，`threshold`是小于3的！

```java
 else if (quarantineSet.size() >= threshold) {
    logger.debug("Clearing quarantined list of size {}", quarantineSet.size());
    quarantineSet.clear();
} 
```

这时会把Set清空，那么再次循环请求的三次还是8761,8762,8763。并且再次注册失败！

那么，问题的关键是什么？

问题的关键就是`threshold`这个值的由来，因为此时`quarantineSet.size()`的值为3，而3这个值大于`threshold`，从而导致，会将`quarantineSet`集合清空，返回全量的Server列表。

### 5.threshold

```java
int threshold = (int) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage());
```

先看代码，他是由配置的host数量乘以一个方法，我们看下这个方法：

```java
private double retryableClientQuarantineRefreshPercentage = 0.66D;
public double getRetryableClientQuarantineRefreshPercentage() {
    return this.retryableClientQuarantineRefreshPercentage;
}
```

可以看到，他是一个默认值，为0.66，所以`4*0.66=2.64`，所以`3>2.64`导致了这个问题，那么我们就应该尝试修改这个值，来达到我们的目的，在`application.properties`修改：

```properties
eureka.client.transport.retryableClientQuarantineRefreshPercentage=1
```

这样当判断是，阈值`threshold=4`，便会直接尝试注册8764了，如果是UP状态会成功连接，达到我们想要的效果