本笔记分析研究对于ES的search功能的原理

## 一、分页

通过之前的学习，我们可以知道搜索时可以通过from和size字段来配置分页信息

```
POST /ecommerce/product/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0,
  "size": 2
}
```

![1571034663141](https://raw.githubusercontent.com/PAcee1/myNote/master/image/1571034663141.png)

我们先进行结果分析，

- took：查询使用12毫秒
- timed_out：没有超时
- _shards：查询请求了多少个分片，成功请求多少个分片
- hits：命中数量，最大匹配分数，具体命中数据

当我们看数据时，发现_id为2的在前，\_id为1的在后，这是es底层分页导致的。

**es分页原理**：举例3个shard，3000条数据，查询from=100，size=10

1. 因为from100，size10，即需要100-109的数据
2. es协调节点向3个shard发出请求，要求获取**每个shard的0-109的数据**，**注意是0-109**
3. 协调节点获取到这些数据，总数据量为330条，**协调节点对这些数据进行排序**
4. 排序后**将序号为100-109的数据返回给客户端**

这时我们会发现，如果数据量增加到30万条，而用户需要最后10条，那么es的协调节点需要**临时存储30万条数据且进行排序**，会导致大量资源耗费，所以对于ES的分页，要尽量避免**DEEP PAGING**的情况。

## 二、全域搜索

ES提供了一种query string的字段，可以将关键词分词再进行搜索，并且可以全域搜索，即不指定查询哪个field

```
POST /ecommerce/product/_search
{
  "query":{
    "query_string": {
	"query": "gaolujie yagao"
    }
  }
}

GET /ecommerce/product/_search?q=gaolujie yagao
```

问题提出：不指定field，ES底层是如何处理并查询所有域呢？难道是对每个field都进行查询吗？

如果对每个field都进行一次查询，太繁琐且性能低，ES的底层不是这样的，它有一个元数据`_all field`，在建立索引保存document的时候，会讲所有域的值串成一个字符串并赋值给元数据_all field。

例如：

```
{
  "name": "jack",
  "age": 26,
  "address": "guangzhou"
}
_all field = "jack 26 guangzhou"
```

当全域搜索的时候只需搜索`_all field`元数据即可

## 三、mapping

我们之前了解mapping就类似一张表的数据结构，定义了多个字段，我们回过头来再研究一下

**1）**在es里直接插入数据时`PUT shop/book/1`及数据信息时，es会自动建立索引、type和mapping

**2）mapping会根据数据自动定义field的数据类型**，如2018-01-01日期格式的数据类型为date，100数字格式的为long

**3）**不同的数据类型可能有的是**exact value精准匹配**，有的是**full text全文检索**。比如text就为全文检索，date就为精准匹配

**4）**exact value在建立倒排索引时，是**整个词**进行建立，full text是使用分词器**分词后**再对不同的词进行建立。所以在搜索时也不同

**5）**mapping的建立可以让**es自动建**，或者**手动设置**mapping的field，包括数据类型，分词器，是否存储，是否索引等等

**这里我们举个例子来看一看精准匹配与全文检索**

![1571043610271](https://raw.githubusercontent.com/PAcee1/myNote/master/image/1571043610271.png)

创建两条数据，website/article，因为是直接插入的，所以mapping是es自动创建的，我们看下mapping格式

![1571043677772](https://raw.githubusercontent.com/PAcee1/myNote/master/image/1571043677772.png)

可以看到author_id是long，post_date是date，和我们上面说的一样。

我们通过上面说的全域搜索query string进行查询一下试一试：

![1571043897206](https://raw.githubusercontent.com/PAcee1/myNote/master/image/1571043897206.png)

可以看到我们全域搜索2017可以查询出2条数据

![1571043986752](https://raw.githubusercontent.com/PAcee1/myNote/master/image/1571043986752.png)

如果我们指定域post_date查询，只能查到一条，为什么呢？

**全域搜索：查询的是\_all field的字段，其类型text属于全文检索，即对2017-01-01这个数据分词后再查询，所以有2条**

**指定域：查询的是post_date字段，其类型date属于精准搜索，即对日期没有分词，又因为es5.x之后的优化，所以能查出一条记录，其实在5.x之前的版本是一条都查不出来的。即只能用2017-01-01这个搜索关键词才能查出。**

