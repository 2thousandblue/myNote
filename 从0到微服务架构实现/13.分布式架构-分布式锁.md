# 分布式锁

## 分布式锁介绍

锁的概念我们在之前的学习中都知道，为了**防止多个线程对同一个变量修改导致一系列问题**，对于这个问题，我们的解决方案都是**使用同步**，比如synchronize 关键字，或者Lock接口保证原子性。

那么既然这样可以解决，分布式锁又是干嘛的，请注意，我们刚刚说的解决方案是**单机环境**的，一个进程中的多个线程，实际是**JVM进行控制**的。

那么如果我们部署分布式项目，多个Tomcat搭建集群那么就有多个JVM，如下

![img](image/7986413-7cc8f57c65d81728.png)

- 成员变量 A 存在 JVM1、JVM2、JVM3 三个 JVM 内存中，成员变量 A 同时都会在 JVM 分配一块内存
- 当三个请求发送过来时，正好每个请求通过轮训请求到不同的三个变量A，因为所在内存不同，数据不共享，所以肯定会出现问题的，每个请求修改A后，下一个请求修改的还是原来的A数据
- 注：该成员变量 A 是一个有状态的对象

如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题！

为了**保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行**，在传统单体应用单机部署的情况下，可以使用并发处理相关的功能进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于**分布式系统多线程、多进程并且分布在不同机器上**，这将使原单机部署情况下的并发控制锁策略失效，单纯的应用并不能提供分布式锁的能力。为了解决这个问题就需要一种**跨机器的互斥机制来控制共享资源的访问**，这就是分布式锁要解决的问题！

## 分布式锁应该具备哪些条件

- 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行
- 高可用的获取锁与释放锁
- 高性能的获取锁与释放锁
- 具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）
- 具备锁失效机制，防止死锁
- 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败

## 单体应用超卖问题

接下来，我们以最经典的超卖问题，一点点从单体锁实现方式到各种分布式锁实现方式的实现。

### 前期代码准备

表：创建了三张表

![image-20200820093534659](image/image-20200820093534659.png)

java工程：springboot

- dao，pojo，使用通用mapper
- service层：实现减少库存，创建订单

```java
@Service
@Slf4j
public class OrderService {

    @Resource
    private OrderMapper orderMapper;
    @Resource
    private OrderItemMapper orderItemMapper;
    @Resource
    private ProductMapper productMapper;

    // 商品id
    private int purchaseProductId = 100100;
    // 购买数量
    private int purchaseProductNum = 1;


    @Transactional(rollbackFor = Exception.class)
    public Integer createOrder() throws Exception{
        Product product = productMapper.selectByPrimaryKey(purchaseProductId);
        if(product == null){
            throw  new  Exception("购买商品"+purchaseProductId + "不存在");
        }

        // 商品库存
        Integer currCount = product.getCount();
        // 校验库存
        if(currCount < purchaseProductNum){
            throw  new  Exception("商品"+purchaseProductId + "仅剩" + currCount + "件，无法购买");
        }
        // 计算剩余库存
        Integer leftCount = currCount - purchaseProductNum;
        product.setCount(leftCount);
        productMapper.updateByPrimaryKeySelective(product);

        // 新建订单
        Orders orders = new Orders();
        orders.setId(new Random().nextInt(10000)+1);
        orders.setOrderAmount(product.getPrice().multiply(new BigDecimal(purchaseProductNum)));
        orders.setReceiverName("xx");
        orders.setOrderStatus("1");
        orderMapper.insertSelective(orders);

        // 新建订单商品
        OrderItem orderItem = new OrderItem();
        orderItem.setId(new Random().nextInt(10000)+1);
        orderItem.setOrderId(orders.getId());
        orderItem.setProductId(product.getId());
        orderItem.setPurchaseNum(purchaseProductNum);
        orderItem.setPurchasePrice(product.getPrice());
        orderItemMapper.insertSelective(orderItem);
        return orders.getId();
    }

}
```

- 测试类：实现并发下单操作

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class LockStudyApplicationTests {

    @Autowired
    private OrderService orderService;

    @Test
    public void contextLoads() throws Exception {
        // 闭锁
        CountDownLatch countDownLatch = new CountDownLatch(5);
        // 线程等待，有5个线程时才执行
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5);

        // 分配5个线程
        ExecutorService es = Executors.newFixedThreadPool(5);
        // 循环跑5个线程
        for (int i = 0; i < 5; i++) {
            // 线程执行
            es.execute(() -> {
                try {
                    // 所有线程等待，等到5个线程同时到时，才会同时执行，即并发
                    cyclicBarrier.await();
                    Integer orderId = orderService.createOrder();
                    System.out.println("订单id为"+orderId);
                } catch (Exception e) {
                    e.printStackTrace();
                }finally {
                    // 闭锁减一
                    countDownLatch.countDown();
                }

            });
        }
        // 当闭锁全部执行完后，才执行后面的代码
        // 目的是和数据库连接池有关，如果主线程执行完了，那么连接会关闭，之后的线程就无法执行了，影响操作
        countDownLatch.await();

        es.shutdown();
    }

}
```

### 超卖现象一 数据库行锁

- 系统中库存为一，但是卖出了两笔订单

这种问题，就是经典的超卖现象，A和B两个买家同时拍下商品并提交订单。

![image-20200819161209601](image/image-20200819161209601.png)

**解决方案**

1. 不在程序中扣减库存，而是在数据库中
2. 数据库传递库存增量，为-1，库存数+增量数
3. 通过update语句计算库存，并使用行锁进行控制并发

**现象**：当前执行代码后，会发现出现5笔订单，但是库存为0

**代码修改**：Service层

```java
/*// 计算剩余库存
Integer leftCount = currCount - purchaseProductNum;
product.setCount(leftCount);
productMapper.updateByPrimaryKeySelective(product);*/
// 使用update 库存增量 修改库存
productMapper.updateProductCount(purchaseProductId,purchaseProductNum);
```

mapper

```xml
<update id="updateProductCount">
  update product
  set count = count - #{purchaseProductNum}
  where id = #{purchaseProductId}
</update>
```

修改过后进行测试

会发现还是会出现5条订单，但商品数量不再是0而是-4了。

说明还有问题，这就需要下面现象二来进行解决。

### 超卖现象二 同步锁

- 系统中库存数量变成了负数，并且还有多个订单生成

问题出现在校验库存那里，并发校验库存，导致出现库存充足的假象。

![image-20200820102959740](image/image-20200820102959740.png)

**解决方案**

- 校验库存和扣减库存操作加锁
- 使两步操作绑定在一起，使其形成原子性操作
- 并发时，只有获得锁的线程才可以校验扣减库存
- 库存扣减结束后释放锁，这样可以确保库存不为负数

**具体实现** 

基于Synchronized解决（最基础的同步锁），代码会进行一些省略

- **方法锁**

将synchronized加在方法上，只有获取到该锁的线程才可以执行此方法

```java
@Autowired
private PlatformTransactionManager platformTransactionManager;
@Autowired
private TransactionDefinition transactionDefinition;

//@Transactional(rollbackFor = Exception.class)
public synchronized Integer createOrder() throws Exception{
    // 手动控制事务
    TransactionStatus transaction = platformTransactionManager.getTransaction(transactionDefinition);

    Product product = productMapper.selectByPrimaryKey(purchaseProductId);
    if(product == null){
        // 手动回滚
        platformTransactionManager.rollback(transaction);
        throw new Exception("购买商品"+purchaseProductId + "不存在");
    }

    // 商品库存
    Integer currCount = product.getCount();
    // 校验库存
    if(currCount < purchaseProductNum){
        platformTransactionManager.rollback(transaction);
        throw new Exception("商品"+purchaseProductId + "仅剩" + currCount + "件，无法购买");
    }
    /*// 计算剩余库存
    Integer leftCount = currCount - purchaseProductNum;
    product.setCount(leftCount);
    productMapper.updateByPrimaryKeySelective(product);*/
    // 使用update 库存增量 修改库存
    productMapper.updateProductCount(purchaseProductId,purchaseProductNum);

    // 新建订单

    // 新建订单商品

    // 手动提交事务
    platformTransactionManager.commit(transaction);
    return orders.getId();
}
```

主在方法上加锁，并手动控制事务（不然在第一个还没提交时，第二个进来会获取到脏数据）

![image-20200820144828337](image/image-20200820144828337.png)

- **块锁**

```java
public Integer createOrder() throws Exception{
    Product product = null;
    // 块锁
    synchronized(this){
        // 手动控制事务
        TransactionStatus transaction = platformTransactionManager.getTransaction(transactionDefinition);
        product = productMapper.selectByPrimaryKey(purchaseProductId);
        if(product == null){
            // 手动回滚
            platformTransactionManager.rollback(transaction);
            throw new Exception("购买商品"+purchaseProductId + "不存在");
        }

        // 商品库存
        Integer currCount = product.getCount();
        // 校验库存
        if(currCount < purchaseProductNum){
            platformTransactionManager.rollback(transaction);
            throw new Exception("商品"+purchaseProductId + "仅剩" + currCount + "件，无法购买");
        }
        /*// 计算剩余库存
        Integer leftCount = currCount - purchaseProductNum;
        product.setCount(leftCount);
        productMapper.updateByPrimaryKeySelective(product);*/
        // 使用update 库存增量 修改库存
        productMapper.updateProductCount(purchaseProductId,purchaseProductNum);

        // 手动提交事务
        platformTransactionManager.commit(transaction);
    }

    // 新建订单

    // 新建订单商品

    return orders.getId();
}
```

在方法的实际代码块上加锁，也可以达到同步

- **ReentranLock**

该锁是JUC并发包中的锁，使用也相当简单

```java
// 并发包中的锁
private Lock lock = new ReentrantLock();

//@Transactional(rollbackFor = Exception.class)
public Integer createOrder() throws Exception{
    Product product = null;

    // 锁住
    lock.lock();
    try{
        // 控制事务，查询库存，校验库存，减少库存
    }finally {
        // 释放锁
        lock.unlock();
    }

    // 新建订单

    // 新建订单商品

    return orders.getId();
}
```

### 局限性

通过之前的学习，我们知道如果是单体项目的话，处于一个JVM，使用Java自带的同步锁进行同步控制，是没有问题的。但是如果是集群呢？有多个JVM启动呢？就会出现问题

为了证实确实会出现问题，这里我们进行测试一下。

使用Springboot项目，并创建一个Controller

```java
@RestController
public class OrderController {

    private Lock lock = new ReentrantLock();

    @RequestMapping("lock")
    public String lock(){
        System.out.println("我进入方法");
        lock.lock();
        System.out.println("我进入锁了");
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        lock.unlock();
        return "执行完成！";
    }

}
```

然后启动两个应用，使用PostMan进行请求

![image-20200820153442032](image/image-20200820153442032.png)![image-20200820153448155](image/image-20200820153448155.png)

会发现两个方法都能进入，说明分布式项目中，使用基础的锁是无效的，必须使用分布式锁才可以。

## 分布式应用锁



